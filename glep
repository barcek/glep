#!/usr/bin/awk -f

# glep v1.11.1
# Â©2023 barcek
# License: MIT
# @ github.com
# /barcek/glep

# Assumes the use of a POSIX shell and
# the presence of AWK (Gawk),
# plus Git, grep and ls

# Run three times per initial command,
# each run being a single named stage,
# all but no. 3 then running the next:
# 1. 'list' (BEGIN; runs no. 2)
# 2. 'grep' (BEGIN & LOOPS; runs no. 3)
# 3. 'echo' (LOOPS)
#
# Arguments to no. 1 are search terms,
# used by default to filter 'git log',
# or flags, each indicating an option;
# any may be a prefixed root or author
# or commit object name for 'git show'

BEGIN { # incl. entire list stage

  defaults_set() # dir_root - root directory
                 # variants - specially formatted search terms or flags
                 # txt_help - help text

  stage = stage ? stage : "list"

  if("list" == stage) {

    # handle non-provision of search terms
    if(ARGC < 2) help_display("No search term provided")

    # extract any specially formatted search terms, consolidating remaining, and
    # handle any options
    for(i = 1; i < length(ARGV); i++) {
      # consolidate if not specially formatted
      split(ARGV[i], base_arr, variants["pre"])
      if(length(base_arr[2]) != length(ARGV[i]) - length(variants["pre"])) {
        terms_arr[j++] = ARGV[i]
        continue
      }
      # extract if root directory
      term_root = term_extract(ARGV[i], variants["terms"]["root"]["pre"])
      if(term_root) {
        split(term_root, path_arr, "/")
        dir_root = !length(path_arr[length(path_arr)]) ? term_root : term_root "/"
        continue
      }
      # extract if commit object name
      if(variants["terms"]["name"]["len"] == length(ARGV[i])) {
        term_name = term_extract(ARGV[i], variants["terms"]["name"]["pre"])
        if(term_name) {
          name_str = term_name
          continue
        }
      }
      # extract if author
      term_auth = term_extract(ARGV[i], variants["terms"]["auth"]["pre"])
      if(term_auth) {
        auth_str = term_auth
        continue
      }
      # handle if regexp extended flag
      if(variants["flags"]["rgxe"]["word"] == ARGV[i] || variants["flags"]["rgxe"]["char"] == ARGV[i]) {
        rgxe_str = "true"
        continue
      }
      # handle if preview flag
      if(variants["flags"]["prvw"]["word"] == ARGV[i] || variants["flags"]["prvw"]["char"] == ARGV[i]) {
        prvw_str = "true"
        continue
      }
      # handle if help flag
      if(variants["flags"]["help"]["word"] == ARGV[i] || variants["flags"]["help"]["char"] == ARGV[i]) help_display()
      # else consolidate
      terms_arr[j++] = ARGV[i]
    }
    # comma-separate any terms beyond name
    terms_str = "\"" terms_arr[0] "\""
    for(i = 1; i < length(terms_arr); i++) {
      terms_str = terms_str ",\"" terms_arr[i] "\""
    }
    # pipe list of dirnames to grep stage
    system(\
      "ls -F " dir_root " | glep -v stage=grep"\
                               " -v terms=" terms_str\
                               " -v  rgxe="  rgxe_str\
                               " -v  prvw="  prvw_str\
                               " -v  root="  dir_root\
                               " -v  name="  name_str\
                               " -v  auth="  auth_str\
    )
    exit 0
  }

  if("grep" == stage) {
    # build grep string for terms passed
    cmd_grep_col = !name ? "always" : "never"
    cmd_grep_ext = !rgxe ? ""       : " -E"
    split(terms, terms_arr, ",")
    for(i = 1; i <= length(terms_arr); i++) {
      cmd_grep = cmd_grep " | grep --color=" cmd_grep_col cmd_grep_ext " \"" terms_arr[i] "\""
    }
    # run commands for root directory
    grep_perform(dir_root)
  }
}

# LOOPS, for grep and echo stages

"grep" == stage && $0 ~ /\/$/ {
  # run commands for next subdirectory
  dir_next = dir_root $0
  grep_perform(dir_next)
}

"echo" == stage {
  # format and output matches for terms
  print "\033[1m" path "\033[0m" $0
}

# UTILS

# initialize default values
function defaults_set() {

  # general
  dir_root = root ? root : "../"

  # special term formats and options
  variants["pre"] = "="
  # - root directory
  variants["terms"]["root"]["pre"] = variants["pre"] ">"
  variants["terms"]["root"]["var"] = "path_to_root"
  variants["terms"]["root"]["exp"] = "an alternative root directory (currently '" dir_root "')"
  # - commit object name
  variants["terms"]["name"]["pre"] = variants["pre"] "#"
  variants["terms"]["name"]["stem_len"] = 7 # commit object name ([0-9a-f]{7})
  variants["terms"]["name"]["len"] = length(variants["terms"]["name"]["pre"]) + variants["terms"]["name"]["stem_len"]
  variants["terms"]["name"]["var"] = "commit_object_name"
  variants["terms"]["name"]["exp"] = "a " variants["terms"]["name"]["stem_len"] "-character hexadecimal commit object name"
  # - author
  variants["terms"]["auth"]["pre"] = variants["pre"] "@"
  variants["terms"]["auth"]["var"] = "author"
  variants["terms"]["auth"]["exp"] = "the commit author"
  # - regexp extended
  variants["flags"]["rgxe"]["char"] = variants["pre"] "e"
  variants["flags"]["rgxe"]["word"] = variants["pre"] "regexp-extended"
  variants["flags"]["rgxe"]["desc"] = "use extended regular expressions in search terms"
  # - help
  variants["flags"]["help"]["char"] = variants["pre"] "h"
  variants["flags"]["help"]["word"] = variants["pre"] "help"
  variants["flags"]["help"]["desc"] = "show usage, terms and flags then exit"
  # - preview
  variants["flags"]["prvw"]["char"] = variants["pre"] "p"
  variants["flags"]["prvw"]["word"] = variants["pre"] "preview"
  variants["flags"]["prvw"]["desc"] = "show but not run the command for the root directory only then exit"

  # help text
  txt_usage = "Usage: glep <search_term>[ ...] [" variants["flags"]["rgxe"]["word"] "/" variants["flags"]["rgxe"]["char"] "] [" variants["flags"]["prvw"]["word"] "/" variants["flags"]["prvw"]["char"] "] / " variants["flags"]["help"]["word"] "/" variants["flags"]["help"]["char"] "\n"
  txt_terms = "Terms:\n Any search term may be one of the following prefixed instances:\n"
  # - get max term parts length for term line spacing
  for(item in variants["terms"]) {
    if(item == "pre") continue
    parts_l = length(variants["terms"][item]["pre"]) + length(variants["terms"][item]["var"])
    space_c = parts_l > space_c ? parts_l : space_c
  }
  # - add term lines
  for(item in variants["terms"]) {
    if(item == "pre") continue
    parts_l = length(variants["terms"][item]["pre"]) + length(variants["terms"][item]["var"])
    spacing = sprintf("%" space_c - parts_l + 2 "s", "")
    txt_terms = txt_terms "  " variants["terms"][item]["pre"] "<" variants["terms"][item]["var"] ">" spacing variants["terms"][item]["exp"] "\n"
  }
  txt_flags = "Flags:\n"
  # - get max flag pair length for flag line spacing
  for(item in variants["flags"]) {
    pairs_l = length(variants["flags"][item]["char"]) + 2 + length(variants["flags"][item]["word"])
    space_c = pairs_l > space_c ? pairs_l : space_c
  }
  # - add flag lines
  for(item in variants["flags"]) {
    pairs_l = length(variants["flags"][item]["char"]) + 2 + length(variants["flags"][item]["word"])
    spacing = sprintf("%" space_c - pairs_l + 2 "s", "")
    txt_flags = txt_flags "  " variants["flags"][item]["char"] ", " variants["flags"][item]["word"] spacing variants["flags"][item]["desc"]
    item_c++; if(item_c != length(variants["flags"])) txt_flags = txt_flags "\n"
  }
  txt_help  = txt_usage txt_terms txt_flags
}

function help_display(msg_err) {
  if(msg_err) print "Error: " msg_err > "/dev/stderr"
  print txt_help > "/dev/stderr"
  exit msg_err ? 1 : 0
}

# return term unprefixed if special else empty string
function term_extract(arg, pre) {
  split(arg, arr, pre)
  return length(arr[2]) == length(arg) - length(pre) ? arr[2] : ""
}

# build and run pipeline performing grep stage tasks
function grep_perform(dir_dest) {
  # set base command to find git directory
  cmd_find = "cd " dir_dest " && ls -a | grep -E '^.git$' > /dev/null"
  # set full command then run:
  # - for 'git log' if no commit object name
  if(!name) {
    cmd_auth = auth ? " --author=" auth : ""
    cmd_full = cmd_find " && matches=$("\
                                       "git log --branches=*"\
                                              cmd_auth\
                                              " --oneline"\
                                              " --format=\"%S | %as %an | %h %s\"" cmd_grep\
                                     ") "\
                        "&& cd - > /dev/null "\
                        "&& echo \"$matches\" | glep -v stage=echo"\
                                                   " -v path=" dir_dest
    if(prvw) { print cmd_full; exit 0 }
    while((cmd_full) | getline line) print line
  }
  # - for 'git show' otherwise, allowing for use of SIGINT
  else {
    cmd_full = cmd_find " && git show --color=always " name " 2> /dev/null" cmd_grep
    if(prvw) { print cmd_full; exit 0 }
    system(cmd_full)
  }
}
