#!/usr/bin/awk -f

# glep v1.13.0
# Â©2023 barcek
# License: MIT
# @ github.com
# /barcek/glep

# Assumes the use of a POSIX shell and
# the presence of AWK (Gawk),
# plus Git, grep and ls

# Run three times per initial command,
# each run being a single named stage,
# all but no. 3 then running the next:
# 1. 'list' (BEGIN; runs no. 2)
# 2. 'grep' (BEGIN & LOOPS; runs no. 3)
# 3. 'echo' (LOOPS)
#
# Arguments to no. 1 are search terms,
# used by default to filter 'git log',
# or flags, each indicating an option;
# any may be a prefixed root or author
# or commit object name for 'git show'

BEGIN { # incl. entire list stage

  defaults_set() # root_str - root directory
                 # variants - specially formatted search terms (t) and option flags (f)
                 # txt_help - help text

  stage = stage ? stage : "list"

  if("list" == stage) {

    # handle non-provision of search terms
    if(ARGC < 2) help_display("No search term provided")

    # get values for any specially formatted terms or flags, consolidating remaining
    for(i = 1; i < length(ARGV); i++) {
      # consolidate then continue if not specially formatted
      split(ARGV[i], base_arr, variants["pre"])
      if(length(base_arr[2]) != length(ARGV[i]) - length(variants["pre"])) {
        terms_arr[j++] = ARGV[i]
        continue
      }
      # get value for specially formatted term - root directory, commit object name, author
      if(variants["t"]["name"]["len"] == length(ARGV[i])) {
        term_name = term_extract(ARGV[i], variants["t"]["name"]["pre"])
        if(term_name) {
          name_str = term_name
          continue
        }
      }
      term_root = term_extract(ARGV[i], variants["t"]["root"]["pre"])
      if(term_root) {
        split(term_root, path_arr, "/")
        root_str = !length(path_arr[length(path_arr)]) ? term_root : term_root "/"
        continue
      }
      term_auth = term_extract(ARGV[i], variants["t"]["auth"]["pre"])
      if(term_auth) {
        auth_str = term_auth
        continue
      }
      # get value for or handle option flag - regexp extended, preview, version, help, test
      if(variants["f"]["rgxe"]["word"] == ARGV[i] || variants["f"]["rgxe"]["char"] == ARGV[i]) {
        rgxe_str = "true"
        continue
      }
      if(variants["f"]["prvw"]["word"] == ARGV[i] || variants["f"]["prvw"]["char"] == ARGV[i]) {
        prvw_str = "true"
        continue
      }
      if(variants["f"]["vrsn"]["word"] == ARGV[i] || variants["f"]["vrsn"]["char"] == ARGV[i]) vrsn_display()
      if(variants["f"]["help"]["word"] == ARGV[i] || variants["f"]["help"]["char"] == ARGV[i]) help_display()
      if(variants["f"]["test"]["word"] == ARGV[i] || variants["f"]["test"]["char"] == ARGV[i]) test_perform()
      # else consolidate
      terms_arr[j++] = ARGV[i]
    }
    # comma-separate any terms beyond name
    terms_str = "\"" terms_arr[0] "\""
    for(i = 1; i < length(terms_arr); i++) {
      terms_str = terms_str ",\"" terms_arr[i] "\""
    }
    # pipe list of dirnames to grep stage
    system(\
      "ls -F " root_str " | glep -v stage=grep"\
                               " -v terms=" terms_str\
                               " -v  rgxe="  rgxe_str\
                               " -v  prvw="  prvw_str\
                               " -v  root="  root_str\
                               " -v  name="  name_str\
                               " -v  auth="  auth_str\
    )
    exit 0
  }

  if("grep" == stage) {
    # build grep string for terms passed
    cmd_grep_col = !name ? "always" : "never"
    cmd_grep_ext = !rgxe ? ""       : " -E"
    split(terms, terms_arr, ",")
    for(i = 1; i <= length(terms_arr); i++) {
      cmd_grep = cmd_grep " | grep --color=" cmd_grep_col cmd_grep_ext " \"" terms_arr[i] "\""
    }
    # run commands for root directory
    grep_perform(root_str)
  }
}

# LOOPS, for grep and echo stages

"grep" == stage && $0 ~ /\/$/ {
  # run commands for next subdirectory
  dir_next = root_str $0
  grep_perform(dir_next)
}

"echo" == stage {
  # format and output matches for terms
  print "\033[1m" path "\033[0m" $0
}

# UTILS

# build and run pipeline performing grep stage tasks
function grep_perform(dir_dest) {
  # set base command to find git directory
  cmd_find = "cd " dir_dest " && ls -a | grep -E '^.git$' > /dev/null"
  # set full command then run:
  # - for 'git log' if no commit object name
  if(!name) {
    cmd_auth = auth ? " --author=" auth : ""
    cmd_full = cmd_find " && matches=$("\
                                       "git log --branches=*"\
                                              cmd_auth\
                                              " --oneline"\
                                              " --format=\"%S | %as %an | %h %s\"" cmd_grep\
                                     ") "\
                        "&& cd - > /dev/null "\
                        "&& echo \"$matches\" | glep -v stage=echo"\
                                                   " -v path=" dir_dest
    if(prvw) { print cmd_full; exit 0 }
    while((cmd_full) | getline line) print line
  }
  # - for 'git show' otherwise, allowing for use of SIGINT
  else {
    cmd_full = cmd_find " && git show --color=always " name " 2> /dev/null" cmd_grep
    if(prvw) { print cmd_full; exit 0 }
    system(cmd_full)
  }
}

# return term unprefixed if special else empty string
function term_extract(arg, pre) {
  split(arg, arr, pre)
  return length(arr[2]) == length(arg) - length(pre) ? arr[2] : ""
}

# run pipeline to print name and version number then exit
function vrsn_display() {
  system("cat glep | head -n 3 | tail -n 1 | awk '{ print $2 \" \" $3}'")
  exit 0
}

# print help text with any error message then exit
function help_display(msg_err) {
  if(msg_err) print "Error: " msg_err > "/dev/stderr"
  print txt_help > "/dev/stderr"
  exit msg_err ? 1 : 0
}

# initialize default values
function defaults_set() {
  # general
  root_str = root ? root : "../"
  # specially formatted search terms (t) and option flags (f)
  variants["pre"] = "="
  # - root directory
  variants["t"]["root"]["pre"] = variants["pre"] ">"
  variants["t"]["root"]["var"] = "path_to_root"
  variants["t"]["root"]["exp"] = "an alternative root directory (currently '" root_str "')"
  # - commit object name
  variants["t"]["name"]["pre"] = variants["pre"] "#"
  variants["t"]["name"]["stem_len"] = 7 # commit object name ([0-9a-f]{7})
  variants["t"]["name"]["len"] = length(variants["t"]["name"]["pre"]) + variants["t"]["name"]["stem_len"]
  variants["t"]["name"]["var"] = "commit_object_name"
  variants["t"]["name"]["exp"] = "a " variants["t"]["name"]["stem_len"] "-character hexadecimal commit object name"
  # - author
  variants["t"]["auth"]["pre"] = variants["pre"] "@"
  variants["t"]["auth"]["var"] = "author"
  variants["t"]["auth"]["exp"] = "the commit author"
  # - regexp extended
  variants["f"]["rgxe"]["char"] = variants["pre"] "e"
  variants["f"]["rgxe"]["word"] = variants["pre"] "regexp-extended"
  variants["f"]["rgxe"]["desc"] = "use extended regular expressions in search terms"
  # - preview
  variants["f"]["prvw"]["char"] = variants["pre"] "p"
  variants["f"]["prvw"]["word"] = variants["pre"] "preview"
  variants["f"]["prvw"]["desc"] = "show but not run the command for the root directory only then exit"
  # - version
  variants["f"]["vrsn"]["char"] = variants["pre"] "v"
  variants["f"]["vrsn"]["word"] = variants["pre"] "version"
  variants["f"]["vrsn"]["desc"] = "show name and version number then exit"
  # - help
  variants["f"]["help"]["char"] = variants["pre"] "h"
  variants["f"]["help"]["word"] = variants["pre"] "help"
  variants["f"]["help"]["desc"] = "show usage, terms and flags then exit"
  # - test
  variants["f"]["test"]["char"] = variants["pre"] "T"
  variants["f"]["test"]["word"] = variants["pre"] "test"
  variants["f"]["test"]["desc"] = "perform the self-test then exit"
  # help text
  txt_usage = "Usage: glep <search_term>[ ...] "\
                "["  variants["f"]["rgxe"]["word"] "/" variants["f"]["rgxe"]["char"] "] "\
                "["  variants["f"]["prvw"]["word"] "/" variants["f"]["prvw"]["char"] "]\n"\
              "            "\
                "/ " variants["f"]["vrsn"]["word"] "/" variants["f"]["vrsn"]["char"] " "\
                "/ " variants["f"]["help"]["word"] "/" variants["f"]["help"]["char"] " "\
                "/ " variants["f"]["test"]["word"] "/" variants["f"]["test"]["char"] "\n"
  txt_terms = "Terms:\n Any search term may be one of the following prefixed instances:\n"
  # - get max term parts length for term line spacing
  for(item in variants["t"]) {
    if(item == "pre") continue
    parts_l = length(variants["t"][item]["pre"]) + length(variants["t"][item]["var"])
    space_c = parts_l > space_c ? parts_l : space_c
  }
  # - add term lines
  for(item in variants["t"]) {
    if(item == "pre") continue
    parts_l = length(variants["t"][item]["pre"]) + length(variants["t"][item]["var"])
    spacing = sprintf("%" space_c - parts_l + 2 "s", "")
    txt_terms = txt_terms "  " variants["t"][item]["pre"] "<" variants["t"][item]["var"] ">" spacing variants["t"][item]["exp"] "\n"
  }
  txt_flags = "Flags:\n"
  # - get max flag pair length for flag line spacing
  for(item in variants["f"]) {
    pairs_l = length(variants["f"][item]["char"]) + 2 + length(variants["f"][item]["word"])
    space_c = pairs_l > space_c ? pairs_l : space_c
  }
  # - add flag lines
  for(item in variants["f"]) {
    pairs_l = length(variants["f"][item]["char"]) + 2 + length(variants["f"][item]["word"])
    spacing = sprintf("%" space_c - pairs_l + 2 "s", "")
    txt_flags = txt_flags "  " variants["f"][item]["char"] ", " variants["f"][item]["word"] spacing variants["f"][item]["desc"]
    item_c++; if(item_c != length(variants["f"])) txt_flags = txt_flags "\n"
  }
  txt_help = txt_usage txt_terms txt_flags
}

function test_case_run(desc, glep, expt) {
  glep | getline rslt
  print rslt == expt ? "PASS: " desc : "FAIL: " desc " | expected " rslt " to equal " expt
}

function test_perform() {

  glep_log_base = "glep =preview a b"
  expt_log_base = "cd ../ && ls -a | grep -E '^.git$' > /dev/null && matches=$(git log --branches=* --oneline --format=\"%S | %as %an | %h %s\" | grep --color=always \"a\" | grep --color=always \"b\") && cd - > /dev/null && echo \"$matches\" | glep -v stage=echo -v path=../"

  glep_log_word = "glep =preview a b =@test \"=>./\" =regexp-extended"
  expt_log_word = "cd ./ && ls -a | grep -E '^.git$' > /dev/null && matches=$(git log --branches=* --author=test --oneline --format=\"%S | %as %an | %h %s\" | grep --color=always -E \"a\" | grep --color=always -E \"b\") && cd - > /dev/null && echo \"$matches\" | glep -v stage=echo -v path=./"

  glep_log_char = "glep =p a b =e"
  expt_log_char = "cd ../ && ls -a | grep -E '^.git$' > /dev/null && matches=$(git log --branches=* --oneline --format=\"%S | %as %an | %h %s\" | grep --color=always -E \"a\" | grep --color=always -E \"b\") && cd - > /dev/null && echo \"$matches\" | glep -v stage=echo -v path=../"

  glep_show_base = "glep =preview a b =#0a1b2c3"
  expt_show_base = "cd ../ && ls -a | grep -E '^.git$' > /dev/null && git show --color=always 0a1b2c3 2> /dev/null | grep --color=never \"a\" | grep --color=never \"b\""

  glep_show_word = "glep =preview a b =#0a1b2c3 =@test \"=>./\" =regexp-extended"
  expt_show_word = "cd ./ && ls -a | grep -E '^.git$' > /dev/null && git show --color=always 0a1b2c3 2> /dev/null | grep --color=never -E \"a\" | grep --color=never -E \"b\""

  glep_show_char = "glep =p a b =#0a1b2c3 =e"
  expt_show_char = "cd ../ && ls -a | grep -E '^.git$' > /dev/null && git show --color=always 0a1b2c3 2> /dev/null | grep --color=never -E \"a\" | grep --color=never -E \"b\""

  glep_str_none = "glep 2>&1 | head -n 1"
  expt_str_none = "Error: No search term provided"

  test_case_run("log/base",  glep_log_base,  expt_log_base)
  test_case_run("log/word",  glep_log_word,  expt_log_word)
  test_case_run("log/char",  glep_log_char,  expt_log_char)
  test_case_run("show/base", glep_show_base, expt_show_base)
  test_case_run("show/word", glep_show_word, expt_show_word)
  test_case_run("show/char", glep_show_char, expt_show_char)
  test_case_run("str/none",  glep_str_none,  expt_str_none)

  exit 0
}
