#!/usr/bin/awk -f

# glep v 1.9.0
# Â©2023 barcek
# License: MIT
# @ github.com
# /barcek/glep

# Run three times per initial command,
# each run being a single named stage,
# all but no. 3 then running the next:
# 1. 'list' (BEGIN; runs no. 2)
# 2. 'grep' (BEGIN & LOOPS; runs no. 3)
# 3. 'echo' (LOOPS)
#
# Arguments to no. 1 are search terms,
# used by default to filter 'git log';
# any may be a prefixed root, author
# or commit object name for 'git show'

BEGIN { # incl. entire list stage

  defaults_set() # dir_root - root directory
                 # specials - specially formatted search terms
                 # txt_help - help text

  stage = stage ? stage : "list"

  if("list" == stage) {

    # handle non-provision of search terms
    if(ARGC < 2) help_display()

    # extract specially formatted search terms, consolidating remaining
    for(i = 1; i < length(ARGV); i++) {
      # consolidate if not specially formatted
      split(ARGV[i], base_arr, specials["pre"])
      if(length(base_arr[2]) != length(ARGV[i]) - length(specials["pre"])) {
        terms_arr[j++] = ARGV[i]
        continue
      }
      # extract if root directory
      term_root = term_extract(ARGV[i], specials["root"]["pre"])
      if(term_root) {
        split(term_root, path_arr, "/")
        dir_root = !length(path_arr[length(path_arr)]) ? term_root : term_root "/"
        continue
      }
      # extract if commit object name
      if(specials["name"]["len"] == length(ARGV[i])) {
        term_name = term_extract(ARGV[i], specials["name"]["pre"])
        if(term_name) {
          name_str = term_name
          continue
        }
      }
      # extract if author
      term_auth = term_extract(ARGV[i], specials["auth"]["pre"])
      if(term_auth) {
        auth_str = term_auth
        continue
      }
      # handle help option
      if(specials["pre"] "help" == ARGV[i] || specials["pre"] "h" == ARGV[i]) help_display()
      # else consolidate
      terms_arr[j++] = ARGV[i]
    }
    # comma-separate any terms beyond name
    terms_str = "\"" terms_arr[0] "\""
    for(i = 1; i < length(terms_arr); i++) {
      terms_str = terms_str ",\"" terms_arr[i] "\""
    }
    # pipe list of dirnames to grep stage
    system(\
      "ls -F " dir_root " | glep -v stage=grep"\
                               " -v terms=" terms_str\
                               " -v  root="  dir_root\
                               " -v  name="  name_str\
                               " -v  auth="  auth_str\
    )
    exit 0
  }

  if("grep" == stage) {
    # build grep string for terms passed
    cmd_grep_col = !name ? "always" : "never"
    split(terms, terms_arr, ",")
    for(i = 1; i <= length(terms_arr); i++) {
      cmd_grep = cmd_grep " | grep --color=" cmd_grep_col " \"" terms_arr[i] "\""
    }
    # run commands for root directory
    grep_perform(dir_root)
  }
}

# LOOPS, for grep and echo stages

"grep" == stage && $0 ~ /\/$/ {
  # run commands for next subdirectory
  dir_next = dir_root $0
  grep_perform(dir_next)
}

"echo" == stage {
  # format and output matches for terms
  print "\033[1m" path "\033[0m" $0
}

# UTILS

# initialize default values
function defaults_set() {
  # general
  dir_root = root ? root : "../"
  # special term formats
  specials["pre"] = "="
  # - root directory
  specials["root"]["pre"] = specials["pre"] ">"
  specials["root"]["var"] = "path_to_root"
  specials["root"]["exp"] = "an alternative root directory (currently '" dir_root "')"
  # - commit object name
  specials["name"]["pre"] = specials["pre"] "#"
  specials["name"]["stem_len"] = 7 # commit object name ([0-9a-f]{7})
  specials["name"]["len"] = length(specials["name"]["pre"]) + specials["name"]["stem_len"]
  specials["name"]["var"] = "commit_object_name"
  specials["name"]["exp"] = "a " specials["name"]["stem_len"] "-character hexadecimal commit object name"
  # - author
  specials["auth"]["pre"] = specials["pre"] "@"
  specials["auth"]["var"] = "author"
  specials["auth"]["exp"] = "the commit author"
  # help text
  txt_usage = "Usage: glep <search_term>[ ...] / " specials["pre"] "help/" specials["pre"] "h\n"
  txt_terms = "Terms:\n Any search term may be one of the following prefixed instances:\n"
  for(item in specials) {
    if(item == "pre") continue
    txt_terms = txt_terms "  " specials[item]["pre"] "<" specials[item]["var"] "> - " specials[item]["exp"] "\n"
  }
  txt_flags = "Flags:\n  " specials["pre"] "h, " specials["pre"] "help   show usage, terms and flags then exit"
  txt_help  = txt_usage txt_terms txt_flags
}

function help_display() {
  print txt_help > "/dev/stderr"
  exit 1
}

# return term unprefixed if special else empty string
function term_extract(arg, pre) {
  split(arg, arr, pre)
  return length(arr[2]) == length(arg) - length(pre) ? arr[2] : ""
}

# build and run pipeline performing grep stage tasks
function grep_perform(dir_dest) {
  # set command to find git directory
  cmd_find = "cd " dir_dest " && ls -a | grep -E '^.git$' > /dev/null"
  # set command for full pipeline per commit object name
  cmd_full = !name ? cmd_find "&& matches=$("\
                                            "git log --branches=*"\
                                                   " --author=" auth\
                                                   " --oneline"\
                                                   " --format=\"%S | %as %an | %h %s\"" cmd_grep\
                                          ") "\
                              "&& cd - > /dev/null "\
                              "&& echo \"$matches\" | glep -v stage=echo"\
                                                         " -v path=" dir_dest\
                   : cmd_find "&& git show --color=always " name " 2> /dev/null " cmd_grep
  system(cmd_full)
}
