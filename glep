#!/usr/bin/awk -f

# glep v 1.3.0
# Â©2023 barcek
# License: MIT
# @ github.com
# /barcek/glep


# Run three times per initial command,
# each run being a single named stage,
# all but no. 3 then running the next:
# 1. 'list' (BEGIN; runs no. 2)
# 2. 'grep' (BEGIN & LOOPS; runs no. 3)
# 3. 'echo' (LOOPS)
#
# Arguments to no. 1 are search terms,
# used by default to filter 'git log';
# one argument may also be a prefixed
# commit object name for use in 'show'

BEGIN { # incl. entire list stage

  # set default values
  dir_root = "../"
  name_len = 2+7 # prefix (=#) + commit object name ([0-9a-f]{7})

  stage = stage ? stage : "list"

  if("list" == stage) {
    # handle non-provision of search terms
    if(ARGC < 2) { print "No search term provided" > "/dev/stderr"; exit 1 }
    # extract any commit object name found,
    # consolidating remaining search terms
    for(i = 1; i < length(ARGV); i++) {
      if(name_len     != length(ARGV[i])    ) { terms_arr[j++] = ARGV[i]; continue }
      split(ARGV[i], name_arr, "=#")
      if(name_len - 2 != length(name_arr[2])) { terms_arr[j++] = ARGV[i]; continue }
      name_str = name_arr[2]
    }
    # comma-separate any terms beyond name
    terms_str = "\"" terms_arr[0] "\""
    for(i = 1; i < length(terms_arr); i++) {
      terms_str = terms_str ",\"" terms_arr[i] "\""
    }
    # pipe list of dirnames to grep stage
    system("ls -F " dir_root " | glep -v stage=grep -v name=" name_str " -v terms=" terms_str)
    exit 0
  }

  if("grep" == stage) {
    # build grep string for terms passed
    cmd_grep_col = !name ? "always" : "never"
    split(terms, terms_arr, ",")
    for(i = 1; i <= length(terms_arr); i++) {
      cmd_grep = cmd_grep " | grep --color=" cmd_grep_col " \"" terms_arr[i] "\""
    }
  }
}

# LOOPS, for grep and echo stages

"grep" == stage && $0 ~ /\/$/ {
  dir_next = dir_root $0
  # set command to find git repositories
  cmd_find = "cd " dir_next " && ls -a | grep -E '^.git$' > /dev/null"
  # set command to pass matches to echo stage
  cmd_pass = "cd - > /dev/null && echo \"$matches\" | glep -v stage=echo -v dir_next=" dir_next
  # set command for full pipeline per commit object name
  cmd_full = !name ? cmd_find "&& matches=$(git log --branches=* --oneline --format=\"%S | %h %s\"" cmd_grep ") && " cmd_pass\
                   : cmd_find "&& git show --color=always " name " 2> /dev/null " cmd_grep
  system(cmd_full)
}

"echo" == stage {
  # format and output matches for terms
  print "\033[1m" dir_next "\033[0m" $0
}
