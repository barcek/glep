#!/usr/bin/awk -f

# glep v 1.1.1
# Â©2023 barcek
# License: MIT
# @ github.com
# /barcek/glep


# Run three times per initial command,
# each run being a single named stage,
# all but no. 3 then running the next:
# 1. 'list' (cf. BEGIN; runs no. 2)
# 2. 'grep' (cf. BEGIN & LOOPS; runs no. 3)
# 3. 'echo' (cf. LOOPS)

BEGIN { # incl. entire list stage

  dir_r = "../"
  stage = stage ? stage : "list"

  if("list" == stage) {
    # handle non-provision of search terms
    if(ARGC < 2) { print "No search term provided" > "/dev/stderr"; exit 1 }
    # comma-separate terms for use in flag
    terms_str = ARGV[1]
    for(i = 2; i < length(ARGV); i++) {
      terms_str = terms_str "," ARGV[i]
    }
    # pipe list of dirnames to grep stage
    system("ls -F " dir_r " | glep -v stage=grep -v terms=" terms_str)
    exit 0
  }

  if("grep" == stage) {
    # build grep string for terms passed
    split(terms, terms_arr, ",")
    for(i = 1; i <= length(terms_arr); i++) {
      greps_str = greps_str " | grep --color=always " terms_arr[i]
    }
  }
}

# LOOPS, for grep and echo stages

"grep" == stage && $0 ~ /\/$/ {
  # pipe matches for terms to echo stage
  dir_s = dir_r $0
  system(\
    "cd " dir_s " && ls -a | grep -E '^.git$' > /dev/null && "\
    "matches=$(git log --branches=* --oneline --format=\"%S | %h %s\"" greps_str ") && "\
    "cd - > /dev/null && echo \"$matches\" | glep -v stage=echo -v dir_s=" dir_s\
  )
}

"echo" == stage {
  # format and output matches for terms
  print "\033[1m" dir_s "\033[0m" $0
}
