#!/usr/bin/awk -f

# glep v1.15.0
# Â©2023 barcek
# License: MIT
# @ github.com
# /barcek/glep

# Assumes the use of a POSIX shell and
# the presence of AWK (Gawk) and Git,
# plus fold, grep, head, ls, sed,
# tail and tr

# Run three times per initial command,
# each run being a single named stage,
# all but no. 3 then running the next:
# 1. 'list' (BEGIN; runs no. 2)
# 2. 'grep' (BEGIN & LOOPS; runs no. 3)
# 3. 'echo' (LOOPS)
#
# Arguments to no. 1 are search terms,
# used by default to filter 'git log',
# or flags, each indicating an option;
# any may be a prefixed root or author
# or commit object name for 'git show'

BEGIN { # incl. entire list stage

  defaults_set() # settings - initially root directory and format string for output
                 # variants - specially formatted search terms (t) and option flags (f)
                 # txt_help - help text

  stage = stage ? stage : "list"

  if("list" == stage) {

    # handle non-provision of search terms
    if(ARGC < 2) help_display("No search term provided")

    # handle any variants, consolidating remaining
    for(i = 1; i < length(ARGV); i++) {
      # consolidate early then continue if not variant
      split(ARGV[i], base_arr, variants["pre"])
      if(length(base_arr[2]) != length(ARGV[i]) - length(variants["pre"])) {
        terms_arr[j++] = ARGV[i]
        continue
      }
      # handle terms
      term_found = ""
      for(term_key in variants["t"]) {
        term = term_extract(ARGV[i], variants["t"][term_key]["pre"])
        # continue early
        if(!term) continue
        if(variants["t"][term_key]["len"] && variants["t"][term_key]["len"] != length(ARGV[i])) continue
        # set then break from inner and continue outer
        settings[term_key] = term
        term_found = "true"
        break
      }
      if(term_found) continue
      # handle flags
      if(variants["f"]["rgxe"]["word"] == ARGV[i] || variants["f"]["rgxe"]["char"] == ARGV[i]) {
        settings["rgxe"] = "true"
        continue
      }
      if(variants["f"]["prvw"]["word"] == ARGV[i] || variants["f"]["prvw"]["char"] == ARGV[i]) {
        settings["prvw"] = "true"
        continue
      }
      if(variants["f"]["list"]["word"] == ARGV[i] || variants["f"]["list"]["char"] == ARGV[i]) {
        settings["list"] = "true"
        continue
      }
      if(variants["f"]["vrsn"]["word"] == ARGV[i] || variants["f"]["vrsn"]["char"] == ARGV[i]) vrsn_display()
      if(variants["f"]["help"]["word"] == ARGV[i] || variants["f"]["help"]["char"] == ARGV[i]) help_display()
      if(variants["f"]["test"]["word"] == ARGV[i] || variants["f"]["test"]["char"] == ARGV[i]) test_perform()
      # else consolidate
      terms_arr[j++] = ARGV[i]
    }
    # comma-separate any terms beyond name
    terms_str = "\"" terms_arr[0] "\""
    for(i = 1; i < length(terms_arr); i++) {
      terms_str = terms_str ",\"" terms_arr[i] "\""
    }
    # ensure separator ends root directory
    split(settings["root"], path_arr, "/")
    settings["root"] = !length(path_arr[length(path_arr)]) ? settings["root"] : settings["root"] "/"
    # pipe list of dirnames to grep stage
    system(\
      "ls -F " settings["root"] " | glep -v stage=grep"\
                               " -v terms="  terms_str\
                               " -v  rgxe="   settings["rgxe"]\
                               " -v  prvw="   settings["prvw"]\
                               " -v  list="   settings["list"]\
                               " -v  root="   settings["root"]\
                               " -v  name="   settings["name"]\
                               " -v  auth="   settings["auth"]\
                               " -v  form=\"" settings["form"] "\""\
    )
    exit 0
  }

  if("grep" == stage) {
    # build grep string for terms passed
    cmd_grep_col = !name ? "always" : "never"
    cmd_grep_ext = !rgxe ? ""       : " -E"
    split(terms, terms_arr, ",")
    for(i = 1; i <= length(terms_arr); i++) {
      cmd_grep = cmd_grep " | grep --color=" cmd_grep_col cmd_grep_ext " \"" terms_arr[i] "\""
    }
    # run commands for root directory
    !list\
      ? grep_perform(settings["root"])\
      : list_perform(settings["root"])
  }
}

# LOOPS, for grep and echo stages

"grep" == stage && $0 ~ /\/$/ {
  # run commands for next subdirectory
  dir_next = settings["root"] $0
  !list\
    ? grep_perform(dir_next)\
    : list_perform(dir_next)
}

"echo" == stage {
  # format and output matches for terms
  print "\033[1m" path "\033[0m" $0
}

# UTILS

# build and run pipeline performing grep stage tasks
function grep_perform(dir_dest) {
  # set base command to find git directory
  cmd_find = "cd " dir_dest " && ls -a | grep -E '^.git$' > /dev/null"
  # set full command then run:
  # - for 'git log' if no commit object name
  if(!name) {
    cmd_auth = auth ? " --author=" auth : ""
    cmd_full = cmd_find " && matches=$("\
                                       "git log --branches=*"\
                                              cmd_auth\
                                              " --oneline"\
                                              " --format=\"" form "\"" cmd_grep\
                                     ") "\
                        "&& cd - > /dev/null "\
                        "&& echo \"$matches\" | glep -v stage=echo"\
                                                   " -v path=" dir_dest
    if(prvw) { print cmd_full; exit 0 }
    while((cmd_full) | getline line) print line
  }
  # - for 'git show' otherwise, allowing for use of SIGINT
  else {
    cmd_full = cmd_find " && git show --color=always " name " 2> /dev/null" cmd_grep
    if(prvw) { print cmd_full; exit 0 }
    system(cmd_full)
  }
}

# run pipeline to print list of git repositories then exit
function list_perform(dir_dest) {
  cmd_list = "cd " dir_dest " && ls -a | grep -E '^.git$' > /dev/null && echo " dir_dest
  if(prvw) { print cmd_list; exit 0 }
  system(cmd_list)
}

# return term unprefixed if special else empty string
function term_extract(arg, pre) {
  split(arg, arr, pre)
  return length(arr[2]) == length(arg) - length(pre) ? arr[2] : ""
}

# run pipeline to print name and version number then exit
function vrsn_display() {
  system("head -n 3 $(command -v glep) | tail -n 1 | awk '{ print $2 \" \" $3}'")
  exit 0
}

# print help text with any error message then exit
function help_display(msg_err) {
  if(msg_err) print "Error: " msg_err > "/dev/stderr"
  print txt_help > "/dev/stderr"
  exit msg_err ? 1 : 0
}

# initialize default values
function defaults_set() {
  # general
  settings["root"] = root ? root : "../"
  settings["form"] = "%S | %as %an | %h %s"
  # specially formatted search terms (t) and option flags (f)
  variants["pre"] = "="
  # - root directory
  variants["t"]["root"]["pre"] = variants["pre"] ">"
  variants["t"]["root"]["var"] = "path_to_root"
  variants["t"]["root"]["exp"] = "an alternative root directory (currently '" settings["root"] "')"
  # - commit object name
  variants["t"]["name"]["pre"] = variants["pre"] "#"
  variants["t"]["name"]["stem_len"] = 7 # commit object name ([0-9a-f]{7})
  variants["t"]["name"]["len"] = length(variants["t"]["name"]["pre"]) + variants["t"]["name"]["stem_len"]
  variants["t"]["name"]["var"] = "commit_object_name"
  variants["t"]["name"]["exp"] = "a " variants["t"]["name"]["stem_len"] "-character hexadecimal commit object name"
  # - author
  variants["t"]["auth"]["pre"] = variants["pre"] "@"
  variants["t"]["auth"]["var"] = "author"
  variants["t"]["auth"]["exp"] = "the commit author"
  # - format
  variants["t"]["form"]["pre"] = variants["pre"] "%"
  variants["t"]["form"]["var"] = "format"
  variants["t"]["form"]["exp"] = "an alternative format string (currently '" settings["form"] "')"
  # - regexp extended
  variants["f"]["rgxe"]["char"] = variants["pre"] "e"
  variants["f"]["rgxe"]["word"] = variants["pre"] "regexp-extended"
  variants["f"]["rgxe"]["desc"] = "use extended regular expressions in search terms"
  # - list
  variants["f"]["list"]["char"] = variants["pre"] "l"
  variants["f"]["list"]["word"] = variants["pre"] "list"
  variants["f"]["list"]["desc"] = "show the list of git repositories to be included"
  # - preview
  variants["f"]["prvw"]["char"] = variants["pre"] "p"
  variants["f"]["prvw"]["word"] = variants["pre"] "preview"
  variants["f"]["prvw"]["desc"] = "show the command for the root directory then exit"
  # - version
  variants["f"]["vrsn"]["char"] = variants["pre"] "v"
  variants["f"]["vrsn"]["word"] = variants["pre"] "version"
  variants["f"]["vrsn"]["desc"] = "show name and version number then exit"
  # - help
  variants["f"]["help"]["char"] = variants["pre"] "h"
  variants["f"]["help"]["word"] = variants["pre"] "help"
  variants["f"]["help"]["desc"] = "show help text, incl. terms and flags, then exit"
  # - test
  variants["f"]["test"]["char"] = variants["pre"] "T"
  variants["f"]["test"]["word"] = variants["pre"] "test"
  variants["f"]["test"]["desc"] = "perform the self-test then exit"
  # help text
  txt_usage = "Usage: glep <search_term>[ ...] "\
                "["  variants["f"]["rgxe"]["word"] "/" variants["f"]["rgxe"]["char"] "] "\
                "["  variants["f"]["prvw"]["word"] "/" variants["f"]["prvw"]["char"] "] "\
                "[ " variants["f"]["list"]["word"] "/" variants["f"]["list"]["char"] "]\n"\
              "            "\
                "/ " variants["f"]["vrsn"]["word"] "/" variants["f"]["vrsn"]["char"] " "\
                "/ " variants["f"]["help"]["word"] "/" variants["f"]["help"]["char"] " "\
                "/ " variants["f"]["test"]["word"] "/" variants["f"]["test"]["char"] "\n"
  txt_terms = "Terms:\n Any search term may be one of the following prefixed instances:\n"
  # - get max term parts length for term line spacing
  for(item in variants["t"]) {
    if(item == "pre") continue
    parts_l = length(variants["t"][item]["pre"]) + length(variants["t"][item]["var"])
    space_c = parts_l > space_c ? parts_l : space_c
  }
  # - add term lines
  for(item in variants["t"]) {
    if(item == "pre") continue
    parts_l = length(variants["t"][item]["pre"]) + length(variants["t"][item]["var"])
    spacing = sprintf("%" space_c - parts_l + 2 "s", "")
    txt_terms = txt_terms "  " variants["t"][item]["pre"] "<" variants["t"][item]["var"] ">" spacing variants["t"][item]["exp"] "\n"
  }
  txt_flags = "Flags:\n"
  # - get max flag pair length for flag line spacing
  for(item in variants["f"]) {
    pairs_l = length(variants["f"][item]["char"]) + 2 + length(variants["f"][item]["word"])
    space_c = pairs_l > space_c ? pairs_l : space_c
  }
  # - add flag lines
  for(item in variants["f"]) {
    pairs_l = length(variants["f"][item]["char"]) + 2 + length(variants["f"][item]["word"])
    spacing = sprintf("%" space_c - pairs_l + 2 "s", "")
    txt_flags = txt_flags "  " variants["f"][item]["char"] ", " variants["f"][item]["word"] spacing variants["f"][item]["desc"] "\n"
  }
  # - add summary lines
  "head -n 22 $(command -v glep) | tail -n 1 | tr -d '\n#'" | getline txt_smry_body_1
  "head -n 25 $(command -v glep) | tail -n 1 | tr -d '\n#' | sed 's/ or / and with a /' | sed 's/for //'" | getline txt_smry_body_2
  txt_smry = "Summary:\n Search terms are" txt_smry_body_1 "\n" txt_smry_body_2 "\n"
  # - add context lines
  "head -n 12 $(command -v glep) | tail -n 4 | tr -d '\n#' | fold -sw 75 | tr '\n' '#'" | getline txt_ctxt_body
  gsub(/#/, "\n ", txt_ctxt_body)
  txt_ctxt = "Context:\n" txt_ctxt_body
  # - combine
  txt_help = txt_usage txt_terms txt_flags txt_smry txt_ctxt

}

function test_case_run(desc, glep, expt) {
  glep | getline rslt
  print rslt == expt ? "PASS: " desc : "FAIL: " desc " | expected " rslt " to equal " expt
}

function test_perform() {

  glep_log_base = "glep =preview a b"
  expt_log_base = "cd ../ && ls -a | grep -E '^.git$' > /dev/null && matches=$(git log --branches=* --oneline --format=\"%S | %as %an | %h %s\" | grep --color=always \"a\" | grep --color=always \"b\") && cd - > /dev/null && echo \"$matches\" | glep -v stage=echo -v path=../"

  glep_log_word = "glep =preview a b =@test \"=>./\" \"=% [test] %s\" =regexp-extended"
  expt_log_word = "cd ./ && ls -a | grep -E '^.git$' > /dev/null && matches=$(git log --branches=* --author=test --oneline --format=\" [test] %s\" | grep --color=always -E \"a\" | grep --color=always -E \"b\") && cd - > /dev/null && echo \"$matches\" | glep -v stage=echo -v path=./"

  glep_log_char = "glep =p a b =e"
  expt_log_char = "cd ../ && ls -a | grep -E '^.git$' > /dev/null && matches=$(git log --branches=* --oneline --format=\"%S | %as %an | %h %s\" | grep --color=always -E \"a\" | grep --color=always -E \"b\") && cd - > /dev/null && echo \"$matches\" | glep -v stage=echo -v path=../"

  glep_show_base = "glep =preview a b =#0a1b2c3"
  expt_show_base = "cd ../ && ls -a | grep -E '^.git$' > /dev/null && git show --color=always 0a1b2c3 2> /dev/null | grep --color=never \"a\" | grep --color=never \"b\""

  glep_show_word = "glep =preview a b =#0a1b2c3 =@test \"=>./\" \"=% [test] %s\" =regexp-extended"
  expt_show_word = "cd ./ && ls -a | grep -E '^.git$' > /dev/null && git show --color=always 0a1b2c3 2> /dev/null | grep --color=never -E \"a\" | grep --color=never -E \"b\""

  glep_show_char = "glep =p a b =#0a1b2c3 =e"
  expt_show_char = "cd ../ && ls -a | grep -E '^.git$' > /dev/null && git show --color=always 0a1b2c3 2> /dev/null | grep --color=never -E \"a\" | grep --color=never -E \"b\""

  glep_list_word = "glep =preview =list"
  expt_list_word = "cd ../ && ls -a | grep -E '^.git$' > /dev/null && echo ../"

  glep_list_char = "glep =p =l"
  expt_list_char = "cd ../ && ls -a | grep -E '^.git$' > /dev/null && echo ../"

  glep_str_none = "glep 2>&1 | head -n 1"
  expt_str_none = "Error: No search term provided"

  test_case_run("log/base",  glep_log_base,  expt_log_base)
  test_case_run("log/word",  glep_log_word,  expt_log_word)
  test_case_run("log/char",  glep_log_char,  expt_log_char)
  test_case_run("show/base", glep_show_base, expt_show_base)
  test_case_run("show/word", glep_show_word, expt_show_word)
  test_case_run("show/char", glep_show_char, expt_show_char)
  test_case_run("list/word", glep_list_word, expt_list_word)
  test_case_run("list/char", glep_list_char, expt_list_char)
  test_case_run("str/none",  glep_str_none,  expt_str_none)

  exit 0
}
